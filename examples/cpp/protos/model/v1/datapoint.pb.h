// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/datapoint.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/model/v1/file.pb.h"
#include "protos/model/v1/health.pb.h"
#include "protos/model/v1/math.pb.h"
#include "protos/model/v1/navigation.pb.h"
#include "protos/model/v1/text.pb.h"
#include "protos/model/v1/media.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fdatapoint_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto;
namespace v1 {
namespace model {
class Datapoint;
class DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class Datapoint_TagsEntry_DoNotUse;
class Datapoint_TagsEntry_DoNotUseDefaultTypeInternal;
extern Datapoint_TagsEntry_DoNotUseDefaultTypeInternal _Datapoint_TagsEntry_DoNotUse_default_instance_;
}  // namespace model
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::model::Datapoint* Arena::CreateMaybeMessage<::v1::model::Datapoint>(Arena*);
template<> ::v1::model::Datapoint_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::Datapoint_TagsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {
namespace model {

// ===================================================================

class Datapoint_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Datapoint_TagsEntry_DoNotUse();
  Datapoint_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Datapoint_TagsEntry_DoNotUse& other);
  static const Datapoint_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Datapoint_TagsEntry_DoNotUse*>(&_Datapoint_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Datapoint.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Datapoint.TagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto);
    return ::descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto.file_level_metadata[0];
  }

  public:
};

// -------------------------------------------------------------------

class Datapoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Datapoint) */ {
 public:
  Datapoint();
  virtual ~Datapoint();

  Datapoint(const Datapoint& from);
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Datapoint& default_instance();

  enum DataCase {
    kText = 4,
    kNumeric = 5,
    kMetricSet = 6,
    kBitset = 7,
    kFile = 8,
    kImage = 9,
    kPointCloud = 10,
    kLocation = 11,
    kLocalization = 12,
    kHealth = 13,
    kJson = 14,
    kBattery = 15,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Datapoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Datapoint* New() const final {
    return CreateMaybeMessage<Datapoint>(nullptr);
  }

  Datapoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Datapoint& from);
  void MergeFrom(const Datapoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datapoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Datapoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto);
    return ::descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kStreamFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kTextFieldNumber = 4,
    kNumericFieldNumber = 5,
    kMetricSetFieldNumber = 6,
    kBitsetFieldNumber = 7,
    kFileFieldNumber = 8,
    kImageFieldNumber = 9,
    kPointCloudFieldNumber = 10,
    kLocationFieldNumber = 11,
    kLocalizationFieldNumber = 12,
    kHealthFieldNumber = 13,
    kJsonFieldNumber = 14,
    kBatteryFieldNumber = 15,
  };
  // map<string, string> tags = 3[json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string stream = 1[json_name = "stream"];
  void clear_stream();
  const std::string& stream() const;
  void set_stream(const std::string& value);
  void set_stream(std::string&& value);
  void set_stream(const char* value);
  void set_stream(const char* value, size_t size);
  std::string* mutable_stream();
  std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // int64 timestamp = 2[json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .v1.model.Text text = 4[json_name = "text"];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::v1::model::Text& text() const;
  ::v1::model::Text* release_text();
  ::v1::model::Text* mutable_text();
  void set_allocated_text(::v1::model::Text* text);
  private:
  const ::v1::model::Text& _internal_text() const;
  ::v1::model::Text* _internal_mutable_text();
  public:

  // .v1.model.Numeric numeric = 5[json_name = "numeric"];
  bool has_numeric() const;
  private:
  bool _internal_has_numeric() const;
  public:
  void clear_numeric();
  const ::v1::model::Numeric& numeric() const;
  ::v1::model::Numeric* release_numeric();
  ::v1::model::Numeric* mutable_numeric();
  void set_allocated_numeric(::v1::model::Numeric* numeric);
  private:
  const ::v1::model::Numeric& _internal_numeric() const;
  ::v1::model::Numeric* _internal_mutable_numeric();
  public:

  // .v1.model.MetricSet metric_set = 6[json_name = "metricSet"];
  bool has_metric_set() const;
  private:
  bool _internal_has_metric_set() const;
  public:
  void clear_metric_set();
  const ::v1::model::MetricSet& metric_set() const;
  ::v1::model::MetricSet* release_metric_set();
  ::v1::model::MetricSet* mutable_metric_set();
  void set_allocated_metric_set(::v1::model::MetricSet* metric_set);
  private:
  const ::v1::model::MetricSet& _internal_metric_set() const;
  ::v1::model::MetricSet* _internal_mutable_metric_set();
  public:

  // .v1.model.Bitset bitset = 7[json_name = "bitset"];
  bool has_bitset() const;
  private:
  bool _internal_has_bitset() const;
  public:
  void clear_bitset();
  const ::v1::model::Bitset& bitset() const;
  ::v1::model::Bitset* release_bitset();
  ::v1::model::Bitset* mutable_bitset();
  void set_allocated_bitset(::v1::model::Bitset* bitset);
  private:
  const ::v1::model::Bitset& _internal_bitset() const;
  ::v1::model::Bitset* _internal_mutable_bitset();
  public:

  // .v1.model.File file = 8[json_name = "file"];
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::v1::model::File& file() const;
  ::v1::model::File* release_file();
  ::v1::model::File* mutable_file();
  void set_allocated_file(::v1::model::File* file);
  private:
  const ::v1::model::File& _internal_file() const;
  ::v1::model::File* _internal_mutable_file();
  public:

  // .v1.model.Image image = 9[json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::v1::model::Image& image() const;
  ::v1::model::Image* release_image();
  ::v1::model::Image* mutable_image();
  void set_allocated_image(::v1::model::Image* image);
  private:
  const ::v1::model::Image& _internal_image() const;
  ::v1::model::Image* _internal_mutable_image();
  public:

  // .v1.model.PointCloud point_cloud = 10[json_name = "pointCloud"];
  bool has_point_cloud() const;
  private:
  bool _internal_has_point_cloud() const;
  public:
  void clear_point_cloud();
  const ::v1::model::PointCloud& point_cloud() const;
  ::v1::model::PointCloud* release_point_cloud();
  ::v1::model::PointCloud* mutable_point_cloud();
  void set_allocated_point_cloud(::v1::model::PointCloud* point_cloud);
  private:
  const ::v1::model::PointCloud& _internal_point_cloud() const;
  ::v1::model::PointCloud* _internal_mutable_point_cloud();
  public:

  // .v1.model.Location location = 11[json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::v1::model::Location& location() const;
  ::v1::model::Location* release_location();
  ::v1::model::Location* mutable_location();
  void set_allocated_location(::v1::model::Location* location);
  private:
  const ::v1::model::Location& _internal_location() const;
  ::v1::model::Location* _internal_mutable_location();
  public:

  // .v1.model.Localization localization = 12[json_name = "localization"];
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::v1::model::Localization& localization() const;
  ::v1::model::Localization* release_localization();
  ::v1::model::Localization* mutable_localization();
  void set_allocated_localization(::v1::model::Localization* localization);
  private:
  const ::v1::model::Localization& _internal_localization() const;
  ::v1::model::Localization* _internal_mutable_localization();
  public:

  // .v1.model.Health health = 13[json_name = "health"];
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::v1::model::Health& health() const;
  ::v1::model::Health* release_health();
  ::v1::model::Health* mutable_health();
  void set_allocated_health(::v1::model::Health* health);
  private:
  const ::v1::model::Health& _internal_health() const;
  ::v1::model::Health* _internal_mutable_health();
  public:

  // .v1.model.Json json = 14[json_name = "json"];
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const ::v1::model::Json& json() const;
  ::v1::model::Json* release_json();
  ::v1::model::Json* mutable_json();
  void set_allocated_json(::v1::model::Json* json);
  private:
  const ::v1::model::Json& _internal_json() const;
  ::v1::model::Json* _internal_mutable_json();
  public:

  // .v1.model.Battery battery = 15[json_name = "battery"];
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  const ::v1::model::Battery& battery() const;
  ::v1::model::Battery* release_battery();
  ::v1::model::Battery* mutable_battery();
  void set_allocated_battery(::v1::model::Battery* battery);
  private:
  const ::v1::model::Battery& _internal_battery() const;
  ::v1::model::Battery* _internal_mutable_battery();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.Datapoint)
 private:
  class _Internal;
  void set_has_text();
  void set_has_numeric();
  void set_has_metric_set();
  void set_has_bitset();
  void set_has_file();
  void set_has_image();
  void set_has_point_cloud();
  void set_has_location();
  void set_has_localization();
  void set_has_health();
  void set_has_json();
  void set_has_battery();

  inline bool has_data() const;
  inline void clear_has_data();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Datapoint_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  union DataUnion {
    DataUnion() {}
    ::v1::model::Text* text_;
    ::v1::model::Numeric* numeric_;
    ::v1::model::MetricSet* metric_set_;
    ::v1::model::Bitset* bitset_;
    ::v1::model::File* file_;
    ::v1::model::Image* image_;
    ::v1::model::PointCloud* point_cloud_;
    ::v1::model::Location* location_;
    ::v1::model::Localization* localization_;
    ::v1::model::Health* health_;
    ::v1::model::Json* json_;
    ::v1::model::Battery* battery_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Datapoint

// string stream = 1[json_name = "stream"];
inline void Datapoint::clear_stream() {
  stream_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Datapoint::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.stream)
  return _internal_stream();
}
inline void Datapoint::set_stream(const std::string& value) {
  _internal_set_stream(value);
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.stream)
}
inline std::string* Datapoint::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.stream)
  return _internal_mutable_stream();
}
inline const std::string& Datapoint::_internal_stream() const {
  return stream_.GetNoArena();
}
inline void Datapoint::_internal_set_stream(const std::string& value) {
  
  stream_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Datapoint::set_stream(std::string&& value) {
  
  stream_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.model.Datapoint.stream)
}
inline void Datapoint::set_stream(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stream_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.model.Datapoint.stream)
}
inline void Datapoint::set_stream(const char* value, size_t size) {
  
  stream_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.model.Datapoint.stream)
}
inline std::string* Datapoint::_internal_mutable_stream() {
  
  return stream_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Datapoint::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.stream)
  
  return stream_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Datapoint::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream);
  // @@protoc_insertion_point(field_set_allocated:v1.model.Datapoint.stream)
}

// int64 timestamp = 2[json_name = "timestamp"];
inline void Datapoint::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Datapoint::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Datapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.timestamp)
  return _internal_timestamp();
}
inline void Datapoint::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void Datapoint::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.timestamp)
}

// map<string, string> tags = 3[json_name = "tags"];
inline int Datapoint::_internal_tags_size() const {
  return tags_.size();
}
inline int Datapoint::tags_size() const {
  return _internal_tags_size();
}
inline void Datapoint::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Datapoint::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Datapoint::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.Datapoint.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Datapoint::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Datapoint::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.Datapoint.tags)
  return _internal_mutable_tags();
}

// .v1.model.Text text = 4[json_name = "text"];
inline bool Datapoint::_internal_has_text() const {
  return data_case() == kText;
}
inline bool Datapoint::has_text() const {
  return _internal_has_text();
}
inline void Datapoint::set_has_text() {
  _oneof_case_[0] = kText;
}
inline ::v1::model::Text* Datapoint::release_text() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.text)
  if (_internal_has_text()) {
    clear_has_data();
      ::v1::model::Text* temp = data_.text_;
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Text& Datapoint::_internal_text() const {
  return _internal_has_text()
      ? *data_.text_
      : *reinterpret_cast< ::v1::model::Text*>(&::v1::model::_Text_default_instance_);
}
inline const ::v1::model::Text& Datapoint::text() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.text)
  return _internal_text();
}
inline ::v1::model::Text* Datapoint::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    data_.text_ = CreateMaybeMessage< ::v1::model::Text >(
        GetArenaNoVirtual());
  }
  return data_.text_;
}
inline ::v1::model::Text* Datapoint::mutable_text() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.text)
  return _internal_mutable_text();
}

// .v1.model.Numeric numeric = 5[json_name = "numeric"];
inline bool Datapoint::_internal_has_numeric() const {
  return data_case() == kNumeric;
}
inline bool Datapoint::has_numeric() const {
  return _internal_has_numeric();
}
inline void Datapoint::set_has_numeric() {
  _oneof_case_[0] = kNumeric;
}
inline ::v1::model::Numeric* Datapoint::release_numeric() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.numeric)
  if (_internal_has_numeric()) {
    clear_has_data();
      ::v1::model::Numeric* temp = data_.numeric_;
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Numeric& Datapoint::_internal_numeric() const {
  return _internal_has_numeric()
      ? *data_.numeric_
      : *reinterpret_cast< ::v1::model::Numeric*>(&::v1::model::_Numeric_default_instance_);
}
inline const ::v1::model::Numeric& Datapoint::numeric() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.numeric)
  return _internal_numeric();
}
inline ::v1::model::Numeric* Datapoint::_internal_mutable_numeric() {
  if (!_internal_has_numeric()) {
    clear_data();
    set_has_numeric();
    data_.numeric_ = CreateMaybeMessage< ::v1::model::Numeric >(
        GetArenaNoVirtual());
  }
  return data_.numeric_;
}
inline ::v1::model::Numeric* Datapoint::mutable_numeric() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.numeric)
  return _internal_mutable_numeric();
}

// .v1.model.MetricSet metric_set = 6[json_name = "metricSet"];
inline bool Datapoint::_internal_has_metric_set() const {
  return data_case() == kMetricSet;
}
inline bool Datapoint::has_metric_set() const {
  return _internal_has_metric_set();
}
inline void Datapoint::set_has_metric_set() {
  _oneof_case_[0] = kMetricSet;
}
inline ::v1::model::MetricSet* Datapoint::release_metric_set() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.metric_set)
  if (_internal_has_metric_set()) {
    clear_has_data();
      ::v1::model::MetricSet* temp = data_.metric_set_;
    data_.metric_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::MetricSet& Datapoint::_internal_metric_set() const {
  return _internal_has_metric_set()
      ? *data_.metric_set_
      : *reinterpret_cast< ::v1::model::MetricSet*>(&::v1::model::_MetricSet_default_instance_);
}
inline const ::v1::model::MetricSet& Datapoint::metric_set() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.metric_set)
  return _internal_metric_set();
}
inline ::v1::model::MetricSet* Datapoint::_internal_mutable_metric_set() {
  if (!_internal_has_metric_set()) {
    clear_data();
    set_has_metric_set();
    data_.metric_set_ = CreateMaybeMessage< ::v1::model::MetricSet >(
        GetArenaNoVirtual());
  }
  return data_.metric_set_;
}
inline ::v1::model::MetricSet* Datapoint::mutable_metric_set() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.metric_set)
  return _internal_mutable_metric_set();
}

// .v1.model.Bitset bitset = 7[json_name = "bitset"];
inline bool Datapoint::_internal_has_bitset() const {
  return data_case() == kBitset;
}
inline bool Datapoint::has_bitset() const {
  return _internal_has_bitset();
}
inline void Datapoint::set_has_bitset() {
  _oneof_case_[0] = kBitset;
}
inline ::v1::model::Bitset* Datapoint::release_bitset() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.bitset)
  if (_internal_has_bitset()) {
    clear_has_data();
      ::v1::model::Bitset* temp = data_.bitset_;
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Bitset& Datapoint::_internal_bitset() const {
  return _internal_has_bitset()
      ? *data_.bitset_
      : *reinterpret_cast< ::v1::model::Bitset*>(&::v1::model::_Bitset_default_instance_);
}
inline const ::v1::model::Bitset& Datapoint::bitset() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.bitset)
  return _internal_bitset();
}
inline ::v1::model::Bitset* Datapoint::_internal_mutable_bitset() {
  if (!_internal_has_bitset()) {
    clear_data();
    set_has_bitset();
    data_.bitset_ = CreateMaybeMessage< ::v1::model::Bitset >(
        GetArenaNoVirtual());
  }
  return data_.bitset_;
}
inline ::v1::model::Bitset* Datapoint::mutable_bitset() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.bitset)
  return _internal_mutable_bitset();
}

// .v1.model.File file = 8[json_name = "file"];
inline bool Datapoint::_internal_has_file() const {
  return data_case() == kFile;
}
inline bool Datapoint::has_file() const {
  return _internal_has_file();
}
inline void Datapoint::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline ::v1::model::File* Datapoint::release_file() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.file)
  if (_internal_has_file()) {
    clear_has_data();
      ::v1::model::File* temp = data_.file_;
    data_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::File& Datapoint::_internal_file() const {
  return _internal_has_file()
      ? *data_.file_
      : *reinterpret_cast< ::v1::model::File*>(&::v1::model::_File_default_instance_);
}
inline const ::v1::model::File& Datapoint::file() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.file)
  return _internal_file();
}
inline ::v1::model::File* Datapoint::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_data();
    set_has_file();
    data_.file_ = CreateMaybeMessage< ::v1::model::File >(
        GetArenaNoVirtual());
  }
  return data_.file_;
}
inline ::v1::model::File* Datapoint::mutable_file() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.file)
  return _internal_mutable_file();
}

// .v1.model.Image image = 9[json_name = "image"];
inline bool Datapoint::_internal_has_image() const {
  return data_case() == kImage;
}
inline bool Datapoint::has_image() const {
  return _internal_has_image();
}
inline void Datapoint::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline ::v1::model::Image* Datapoint::release_image() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.image)
  if (_internal_has_image()) {
    clear_has_data();
      ::v1::model::Image* temp = data_.image_;
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Image& Datapoint::_internal_image() const {
  return _internal_has_image()
      ? *data_.image_
      : *reinterpret_cast< ::v1::model::Image*>(&::v1::model::_Image_default_instance_);
}
inline const ::v1::model::Image& Datapoint::image() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.image)
  return _internal_image();
}
inline ::v1::model::Image* Datapoint::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_data();
    set_has_image();
    data_.image_ = CreateMaybeMessage< ::v1::model::Image >(
        GetArenaNoVirtual());
  }
  return data_.image_;
}
inline ::v1::model::Image* Datapoint::mutable_image() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.image)
  return _internal_mutable_image();
}

// .v1.model.PointCloud point_cloud = 10[json_name = "pointCloud"];
inline bool Datapoint::_internal_has_point_cloud() const {
  return data_case() == kPointCloud;
}
inline bool Datapoint::has_point_cloud() const {
  return _internal_has_point_cloud();
}
inline void Datapoint::set_has_point_cloud() {
  _oneof_case_[0] = kPointCloud;
}
inline ::v1::model::PointCloud* Datapoint::release_point_cloud() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.point_cloud)
  if (_internal_has_point_cloud()) {
    clear_has_data();
      ::v1::model::PointCloud* temp = data_.point_cloud_;
    data_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::PointCloud& Datapoint::_internal_point_cloud() const {
  return _internal_has_point_cloud()
      ? *data_.point_cloud_
      : *reinterpret_cast< ::v1::model::PointCloud*>(&::v1::model::_PointCloud_default_instance_);
}
inline const ::v1::model::PointCloud& Datapoint::point_cloud() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.point_cloud)
  return _internal_point_cloud();
}
inline ::v1::model::PointCloud* Datapoint::_internal_mutable_point_cloud() {
  if (!_internal_has_point_cloud()) {
    clear_data();
    set_has_point_cloud();
    data_.point_cloud_ = CreateMaybeMessage< ::v1::model::PointCloud >(
        GetArenaNoVirtual());
  }
  return data_.point_cloud_;
}
inline ::v1::model::PointCloud* Datapoint::mutable_point_cloud() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.point_cloud)
  return _internal_mutable_point_cloud();
}

// .v1.model.Location location = 11[json_name = "location"];
inline bool Datapoint::_internal_has_location() const {
  return data_case() == kLocation;
}
inline bool Datapoint::has_location() const {
  return _internal_has_location();
}
inline void Datapoint::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline ::v1::model::Location* Datapoint::release_location() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.location)
  if (_internal_has_location()) {
    clear_has_data();
      ::v1::model::Location* temp = data_.location_;
    data_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Location& Datapoint::_internal_location() const {
  return _internal_has_location()
      ? *data_.location_
      : *reinterpret_cast< ::v1::model::Location*>(&::v1::model::_Location_default_instance_);
}
inline const ::v1::model::Location& Datapoint::location() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.location)
  return _internal_location();
}
inline ::v1::model::Location* Datapoint::_internal_mutable_location() {
  if (!_internal_has_location()) {
    clear_data();
    set_has_location();
    data_.location_ = CreateMaybeMessage< ::v1::model::Location >(
        GetArenaNoVirtual());
  }
  return data_.location_;
}
inline ::v1::model::Location* Datapoint::mutable_location() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.location)
  return _internal_mutable_location();
}

// .v1.model.Localization localization = 12[json_name = "localization"];
inline bool Datapoint::_internal_has_localization() const {
  return data_case() == kLocalization;
}
inline bool Datapoint::has_localization() const {
  return _internal_has_localization();
}
inline void Datapoint::set_has_localization() {
  _oneof_case_[0] = kLocalization;
}
inline ::v1::model::Localization* Datapoint::release_localization() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.localization)
  if (_internal_has_localization()) {
    clear_has_data();
      ::v1::model::Localization* temp = data_.localization_;
    data_.localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Localization& Datapoint::_internal_localization() const {
  return _internal_has_localization()
      ? *data_.localization_
      : *reinterpret_cast< ::v1::model::Localization*>(&::v1::model::_Localization_default_instance_);
}
inline const ::v1::model::Localization& Datapoint::localization() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.localization)
  return _internal_localization();
}
inline ::v1::model::Localization* Datapoint::_internal_mutable_localization() {
  if (!_internal_has_localization()) {
    clear_data();
    set_has_localization();
    data_.localization_ = CreateMaybeMessage< ::v1::model::Localization >(
        GetArenaNoVirtual());
  }
  return data_.localization_;
}
inline ::v1::model::Localization* Datapoint::mutable_localization() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.localization)
  return _internal_mutable_localization();
}

// .v1.model.Health health = 13[json_name = "health"];
inline bool Datapoint::_internal_has_health() const {
  return data_case() == kHealth;
}
inline bool Datapoint::has_health() const {
  return _internal_has_health();
}
inline void Datapoint::set_has_health() {
  _oneof_case_[0] = kHealth;
}
inline ::v1::model::Health* Datapoint::release_health() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.health)
  if (_internal_has_health()) {
    clear_has_data();
      ::v1::model::Health* temp = data_.health_;
    data_.health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Health& Datapoint::_internal_health() const {
  return _internal_has_health()
      ? *data_.health_
      : *reinterpret_cast< ::v1::model::Health*>(&::v1::model::_Health_default_instance_);
}
inline const ::v1::model::Health& Datapoint::health() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.health)
  return _internal_health();
}
inline ::v1::model::Health* Datapoint::_internal_mutable_health() {
  if (!_internal_has_health()) {
    clear_data();
    set_has_health();
    data_.health_ = CreateMaybeMessage< ::v1::model::Health >(
        GetArenaNoVirtual());
  }
  return data_.health_;
}
inline ::v1::model::Health* Datapoint::mutable_health() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.health)
  return _internal_mutable_health();
}

// .v1.model.Json json = 14[json_name = "json"];
inline bool Datapoint::_internal_has_json() const {
  return data_case() == kJson;
}
inline bool Datapoint::has_json() const {
  return _internal_has_json();
}
inline void Datapoint::set_has_json() {
  _oneof_case_[0] = kJson;
}
inline ::v1::model::Json* Datapoint::release_json() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.json)
  if (_internal_has_json()) {
    clear_has_data();
      ::v1::model::Json* temp = data_.json_;
    data_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Json& Datapoint::_internal_json() const {
  return _internal_has_json()
      ? *data_.json_
      : *reinterpret_cast< ::v1::model::Json*>(&::v1::model::_Json_default_instance_);
}
inline const ::v1::model::Json& Datapoint::json() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.json)
  return _internal_json();
}
inline ::v1::model::Json* Datapoint::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_data();
    set_has_json();
    data_.json_ = CreateMaybeMessage< ::v1::model::Json >(
        GetArenaNoVirtual());
  }
  return data_.json_;
}
inline ::v1::model::Json* Datapoint::mutable_json() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.json)
  return _internal_mutable_json();
}

// .v1.model.Battery battery = 15[json_name = "battery"];
inline bool Datapoint::_internal_has_battery() const {
  return data_case() == kBattery;
}
inline bool Datapoint::has_battery() const {
  return _internal_has_battery();
}
inline void Datapoint::set_has_battery() {
  _oneof_case_[0] = kBattery;
}
inline ::v1::model::Battery* Datapoint::release_battery() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.battery)
  if (_internal_has_battery()) {
    clear_has_data();
      ::v1::model::Battery* temp = data_.battery_;
    data_.battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Battery& Datapoint::_internal_battery() const {
  return _internal_has_battery()
      ? *data_.battery_
      : *reinterpret_cast< ::v1::model::Battery*>(&::v1::model::_Battery_default_instance_);
}
inline const ::v1::model::Battery& Datapoint::battery() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.battery)
  return _internal_battery();
}
inline ::v1::model::Battery* Datapoint::_internal_mutable_battery() {
  if (!_internal_has_battery()) {
    clear_data();
    set_has_battery();
    data_.battery_ = CreateMaybeMessage< ::v1::model::Battery >(
        GetArenaNoVirtual());
  }
  return data_.battery_;
}
inline ::v1::model::Battery* Datapoint::mutable_battery() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.battery)
  return _internal_mutable_battery();
}

inline bool Datapoint::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Datapoint::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Datapoint::DataCase Datapoint::data_case() const {
  return Datapoint::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
